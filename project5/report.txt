1. Enter the number of hours it took you to complete the project between
   the <<< and >>> signs below (eg, <<<10>>>).

   <<<48>>>
   
2. Enter the difficulty level (1: very easy; 5: very difficult) of the project
   between the <<< and >>> signs below (eg, <<<3>>>).

   <<<5>>>

3. Did you receive help from anyone? List their names, status (classmate, 
   CS110 grad, TA, other), and the nature of help received.

   Name               Status       Help Received
   Aayush Shrivastava  TA          Explained the concept of problem 1, 2, 3, and 4
                                   about how the problems will work togther.
                                   Explained how to connect interval.py with rectangle.py.
                                   How to use the functions inside interval.py.

   Kenichi Maeda     LA            In problwm 1, explained the concept of running average
                                   finding the right value for x, y, and pixels.

4. Provide a short description of how you approached each problem, issues you 
   encountered, and how you resolved those issues.

   Problem 1 (Particle Representation)
      Approach: Set the the variables: x, y, and pixels. Write a function
      that add pixel (x, y) to this blob. Inside the function, I need to set up
      the running average and add pixels by 1.
      In mass function, I just needed to return the mass of pixels.
      In distanceTo function, set up the distance equation between two points and return it.

      Issues and resolution: I had a problem understanding the definition of running average.
      However, Aayush and Kenichi helped me understand the meaning of the average
      by showing how it can be set up.

   Problem 2 (Particle Identification)
      Approach: # Constructs a blob finder to find blobs in the picture pic,
      using a luminance threshold tau. Initialize an empty list for the blobs in pic.
      Create a 2D list of booleans called marked, having the same dimensions as pic.
      Set x and y so that the list marked can be the same demensions as the pic.
      Enumerate the pixels of pic, and for each pixel (i, j):
      Create a Blob object called blob. Call self._findBlob() with the right arguments.
      Add blob to self.blobs if it has a non-zero mass.
      In getBeads function, create an empty list for blobs. Use for loop
      to check the blob masses greater or equaled to pixels. Then add them in the list.
      In _findBlob, return if pixel (i, j) is out of bounds, or if it is marked, or if its
      luminance is less than tau. Mark the pixel. Add the pixel to blob.
      set up East, West, South, North.

      Issues and resolution: It was really hard to set up for getBeads how i can add
      only blobs that us greater or equaled to pixels. However, thinking about for loop concept
      I was able to manage it to check every element in the list and add it.
      For _findBlob, I struggled to understand "Mark the pixels", "add the pixel to blob".
      However, since i and j are the rows and columns of pixels, I put the values in as it is.
      It worked.

   Problem 3 (Particle Tracking)
      Approach: Accept command-line arguments pixels (int), tau (float), and delta (float).
      Construct a BlobFinder object for the frame sys.argv[4]
      From it get a list of beads prevBeads that have at least pixels
      Construct a BlobFinder object. Get a list of beads currBeads that have at least pixels.
      For each bead currBead in currBeads, find a bead prevBead from prevBeads
      that is no further than delta and is closest to currBead
      if such a bead is found, write its distance to currBead. Write a newline character.
      Set prevBeads to currBeads.


      Issues and resolution: At first, I didn't know how I would manage all the input. But,
      after a while, I understood that you can just create a list that starts from 4th sys.argv.
      Later, for cheking the currBead, I had no idea what to do.
      I had to wonder around and ask TAs and LA what I need to do.

   Problem 4 (Data Analysis)
      Approach: Initialize ETA, RHO, T, and R to appropriate values.
      Calculate var as the sum of the squares of the n displacements
      (each converted from pixels to meters) read from standard input.
      Divide var by 2 * n. Estimate Boltzmann’s constant as 6 * math.pi * var * ETA * RHO / T.
      Estimate Avogadro’s constant as R / k.
      Write to standard output the two constants in scientific notation.
      (using the format string ’%e’) and separated by a space.

      Issues and resolution: At first, I got RHD, T, and R values right, but I didn't know
      what was ETA. Therefore, I asked Kenichi(LA). After it, the LA also hinted me to use
      while not stdio.isEmpty(): for "n" and "var"

5. List any other comments here. Feel free to provide any feedback on how
   much you learned from doing the assignment, and whether you enjoyed
   doing it.

   It was the hardest project so far. Although I don't stil have a full understanding of
   this blob project, it helped me understand the programming process by going through
   4 problems.
